{"version":3,"file":"index.cjs","names":["geomCol: Vector","lng: number","lat: number","x: number","y: number","options: ArrowClusterEngineOptions","table: Table","data: number[]","bbox: [number, number, number, number]","zoom: number","clusterId: number","children: number[]","indices: number[]","result: number[]","limit: number","offset: number","skipped: number","tree: KDBush","nextData: number[]","KDBush","a: ClusterOutput","b: ClusterOutput"],"sources":["../src/arrow-helpers.ts","../src/mercator.ts","../src/arrow-cluster-engine.ts"],"sourcesContent":["import type { Vector } from \"apache-arrow\";\n\n/**\n * Extract the raw Float64Array coordinate buffer from a GeoArrow Point column.\n *\n * GeoArrow Point encoding: FixedSizeList[2] of Float64\n * Buffer layout: [lng0, lat0, lng1, lat1, ...]\n *\n * This accesses Arrow's internal buffer directly — zero copy.\n * Single-chunk only in this version.\n */\nexport function getCoordBuffer(geomCol: Vector): Float64Array {\n  const data = geomCol.data[0];\n\n  // GeoArrow Point = FixedSizeList[2] → children[0] is the Float64 values vector\n  if (data.children && data.children.length > 0) {\n    const values = data.children[0].values;\n    if (values instanceof Float64Array) {\n      return values;\n    }\n  }\n\n  // Fallback: manually extract coordinates via the public API\n  const numRows = geomCol.length;\n  const coords = new Float64Array(numRows * 2);\n  for (let i = 0; i < numRows; i++) {\n    const point = geomCol.get(i);\n    if (point) {\n      coords[i * 2] = point[0];\n      coords[i * 2 + 1] = point[1];\n    } else {\n      coords[i * 2] = NaN;\n      coords[i * 2 + 1] = NaN;\n    }\n  }\n  return coords;\n}\n","/**\n * Mercator projection utilities — same math as Supercluster.\n * Converts between lng/lat (WGS84) and Mercator x/y (0..1 range).\n */\n\nconst { fround } = Math;\n\n/** Longitude to Mercator x (0..1) */\nexport function lngX(lng: number): number {\n  return lng / 360 + 0.5;\n}\n\n/** Latitude to Mercator y (0..1) */\nexport function latY(lat: number): number {\n  const sin = Math.sin((lat * Math.PI) / 180);\n  const y = 0.5 - (0.25 * Math.log((1 + sin) / (1 - sin))) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n/** Mercator x (0..1) to longitude */\nexport function xLng(x: number): number {\n  return (x - 0.5) * 360;\n}\n\n/** Mercator y (0..1) to latitude */\nexport function yLat(y: number): number {\n  const y2 = ((180 - y * 360) * Math.PI) / 180;\n  return (360 * Math.atan(Math.exp(y2))) / Math.PI - 90;\n}\n\nexport { fround };\n","import KDBush from \"kdbush\";\nimport type { Table } from \"apache-arrow\";\nimport { getCoordBuffer } from \"./arrow-helpers\";\nimport { lngX, latY, xLng, yLat, fround } from \"./mercator\";\nimport type { ClusterOutput, ArrowClusterEngineOptions } from \"./types\";\n\n// Offsets into the flat data array (stride = 6)\nconst OFFSET_ZOOM = 2;\nconst OFFSET_ID = 3;\nconst OFFSET_PARENT = 4;\nconst OFFSET_NUM = 5;\nconst STRIDE = 6;\n\n/**\n * Arrow-native spatial clustering engine.\n *\n * Reimplements Supercluster's algorithm to work directly with Apache Arrow\n * typed array buffers. No GeoJSON, no rendering opinion.\n */\nexport class ArrowClusterEngine {\n  private trees: KDBush[] = [];\n  private treeData: number[][] = [];\n  private numPoints = 0;\n  private table: Table | null = null;\n\n  readonly radius: number;\n  readonly extent: number;\n  readonly minZoom: number;\n  readonly maxZoom: number;\n  readonly minPoints: number;\n\n  constructor(options: ArrowClusterEngineOptions = {}) {\n    this.radius = options.radius ?? 40;\n    this.extent = options.extent ?? 512;\n    this.minZoom = options.minZoom ?? 0;\n    this.maxZoom = options.maxZoom ?? 16;\n    this.minPoints = options.minPoints ?? 2;\n  }\n\n  /**\n   * Load an Arrow Table and build the spatial index.\n   */\n  load(table: Table, geometryColumn = \"geometry\", _idColumn = \"id\"): void {\n    this.table = table;\n    this.numPoints = table.numRows;\n\n    const geomCol = table.getChild(geometryColumn);\n    if (!geomCol) {\n      throw new Error(\n        `Geometry column \"${geometryColumn}\" not found in Arrow Table`,\n      );\n    }\n\n    const coordValues = getCoordBuffer(geomCol);\n\n    // Build the initial flat data array from Arrow coordinates\n    const data: number[] = [];\n    for (let i = 0; i < this.numPoints; i++) {\n      const lng = coordValues[i * 2];\n      const lat = coordValues[i * 2 + 1];\n\n      if (\n        lng === null ||\n        lat === null ||\n        Number.isNaN(lng) ||\n        Number.isNaN(lat)\n      ) {\n        continue;\n      }\n\n      data.push(\n        fround(lngX(lng)),\n        fround(latY(lat)),\n        Infinity, // last zoom processed at\n        i, // source feature index (Arrow row index)\n        -1, // parent cluster id\n        1, // point count\n      );\n    }\n\n    let tree = this._createTree(data);\n    this.trees[this.maxZoom + 1] = tree;\n    this.treeData[this.maxZoom + 1] = data;\n\n    for (let z = this.maxZoom; z >= this.minZoom; z--) {\n      const nextData = this._cluster(tree, this.treeData[z + 1], z);\n      tree = this._createTree(nextData);\n      this.trees[z] = tree;\n      this.treeData[z] = nextData;\n    }\n  }\n\n  /**\n   * Get clusters and individual points for a bounding box at a given zoom level.\n   */\n  getClusters(\n    bbox: [number, number, number, number],\n    zoom: number,\n  ): ClusterOutput {\n    let minLng = ((((bbox[0] + 180) % 360) + 360) % 360) - 180;\n    const minLat = Math.max(-90, Math.min(90, bbox[1]));\n    let maxLng =\n      bbox[2] === 180 ? 180 : ((((bbox[2] + 180) % 360) + 360) % 360) - 180;\n    const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      const eastern = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      const western = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return this._mergeOutputs(eastern, western);\n    }\n\n    const z = this._limitZoom(zoom);\n    const tree = this.trees[z];\n    const data = this.treeData[z];\n    if (!tree || !data) return this._emptyOutput();\n\n    const resultIds = tree.range(\n      lngX(minLng),\n      latY(maxLat),\n      lngX(maxLng),\n      latY(minLat),\n    );\n\n    const length = resultIds.length;\n    const positions = new Float64Array(length * 2);\n    const pointCounts = new Uint32Array(length);\n    const ids = new Float64Array(length);\n    const isCluster = new Uint8Array(length);\n\n    for (let i = 0; i < length; i++) {\n      const k = resultIds[i] * STRIDE;\n      positions[i * 2] = xLng(data[k]);\n      positions[i * 2 + 1] = yLat(data[k + 1]);\n      pointCounts[i] = data[k + OFFSET_NUM];\n      ids[i] = data[k + OFFSET_ID];\n      isCluster[i] = data[k + OFFSET_NUM] > 1 ? 1 : 0;\n    }\n\n    return { positions, pointCounts, ids, isCluster, length };\n  }\n\n  /**\n   * Get the immediate children of a cluster.\n   */\n  getChildren(clusterId: number): ClusterOutput {\n    const originId = this._getOriginId(clusterId);\n    const originZoom = this._getOriginZoom(clusterId);\n\n    const tree = this.trees[originZoom];\n    const data = this.treeData[originZoom];\n    if (!tree || !data) return this._emptyOutput();\n    if (originId * STRIDE >= data.length) return this._emptyOutput();\n\n    const r = this.radius / (this.extent * Math.pow(2, originZoom - 1));\n    const x = data[originId * STRIDE];\n    const y = data[originId * STRIDE + 1];\n    const neighborIds = tree.within(x, y, r);\n\n    const children: number[] = [];\n    for (const nid of neighborIds) {\n      const k = nid * STRIDE;\n      if (data[k + OFFSET_PARENT] === clusterId) {\n        children.push(nid);\n      }\n    }\n\n    const length = children.length;\n    const positions = new Float64Array(length * 2);\n    const pointCounts = new Uint32Array(length);\n    const ids = new Float64Array(length);\n    const isCluster = new Uint8Array(length);\n\n    for (let i = 0; i < length; i++) {\n      const k = children[i] * STRIDE;\n      positions[i * 2] = xLng(data[k]);\n      positions[i * 2 + 1] = yLat(data[k + 1]);\n      pointCounts[i] = data[k + OFFSET_NUM];\n      ids[i] = data[k + OFFSET_ID];\n      isCluster[i] = data[k + OFFSET_NUM] > 1 ? 1 : 0;\n    }\n\n    return { positions, pointCounts, ids, isCluster, length };\n  }\n\n  /**\n   * Get the Arrow row indices of all leaf points in a cluster.\n   */\n  getLeaves(clusterId: number, limit = Infinity, offset = 0): number[] {\n    const indices: number[] = [];\n    this._appendLeafIndices(indices, clusterId, limit, offset, 0);\n    return indices;\n  }\n\n  /**\n   * Get the zoom level at which a cluster expands into its children.\n   */\n  getClusterExpansionZoom(clusterId: number): number {\n    let expansionZoom = this._getOriginZoom(clusterId) - 1;\n\n    while (expansionZoom <= this.maxZoom) {\n      const children = this.getChildren(clusterId);\n      expansionZoom++;\n      if (children.length !== 1) break;\n      if (children.isCluster[0]) {\n        clusterId = children.ids[0];\n      } else {\n        break;\n      }\n    }\n\n    return expansionZoom;\n  }\n\n  /** Decode the zoom level from a cluster ID. */\n  getOriginZoom(clusterId: number): number {\n    return this._getOriginZoom(clusterId);\n  }\n\n  /** Decode the origin index from a cluster ID. */\n  getOriginId(clusterId: number): number {\n    return this._getOriginId(clusterId);\n  }\n\n  // --- Private methods ---\n\n  private _getOriginZoom(clusterId: number): number {\n    return (clusterId - this.numPoints) % 32;\n  }\n\n  private _getOriginId(clusterId: number): number {\n    return (clusterId - this.numPoints) >> 5;\n  }\n\n  private _appendLeafIndices(\n    result: number[],\n    clusterId: number,\n    limit: number,\n    offset: number,\n    skipped: number,\n  ): number {\n    const children = this.getChildren(clusterId);\n\n    for (let i = 0; i < children.length; i++) {\n      if (children.isCluster[i]) {\n        if (skipped + children.pointCounts[i] <= offset) {\n          skipped += children.pointCounts[i];\n        } else {\n          skipped = this._appendLeafIndices(\n            result,\n            children.ids[i],\n            limit,\n            offset,\n            skipped,\n          );\n          if (result.length >= limit) return skipped;\n        }\n      } else {\n        if (skipped < offset) {\n          skipped++;\n        } else {\n          result.push(children.ids[i]);\n          if (result.length >= limit) return skipped;\n        }\n      }\n    }\n\n    return skipped;\n  }\n\n  /**\n   * Cluster points at a given zoom level.\n   * Matches Supercluster._cluster() exactly.\n   */\n  private _cluster(tree: KDBush, data: number[], zoom: number): number[] {\n    const r = this.radius / (this.extent * Math.pow(2, zoom));\n    const nextData: number[] = [];\n\n    for (let i = 0; i < data.length; i += STRIDE) {\n      if (data[i + OFFSET_ZOOM] <= zoom) continue;\n      data[i + OFFSET_ZOOM] = zoom;\n\n      const x = data[i];\n      const y = data[i + 1];\n      const neighborIds = tree.within(x, y, r);\n\n      const numPointsOrigin = data[i + OFFSET_NUM];\n      let numPoints = numPointsOrigin;\n\n      for (const neighborId of neighborIds) {\n        const k = neighborId * STRIDE;\n        if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n      }\n\n      if (numPoints > numPointsOrigin && numPoints >= this.minPoints) {\n        let wx = x * numPointsOrigin;\n        let wy = y * numPointsOrigin;\n\n        const id = (((i / STRIDE) | 0) << 5) + (zoom + 1) + this.numPoints;\n\n        for (const neighborId of neighborIds) {\n          const k = neighborId * STRIDE;\n          if (data[k + OFFSET_ZOOM] <= zoom) continue;\n          data[k + OFFSET_ZOOM] = zoom;\n\n          const numPoints2 = data[k + OFFSET_NUM];\n          wx += data[k] * numPoints2;\n          wy += data[k + 1] * numPoints2;\n\n          data[k + OFFSET_PARENT] = id;\n        }\n\n        data[i + OFFSET_PARENT] = id;\n        nextData.push(\n          wx / numPoints,\n          wy / numPoints,\n          Infinity,\n          id,\n          -1,\n          numPoints,\n        );\n      } else {\n        for (let j = 0; j < STRIDE; j++) nextData.push(data[i + j]);\n\n        if (numPoints > 1) {\n          for (const neighborId of neighborIds) {\n            const k = neighborId * STRIDE;\n            if (data[k + OFFSET_ZOOM] <= zoom) continue;\n            data[k + OFFSET_ZOOM] = zoom;\n            for (let j = 0; j < STRIDE; j++) nextData.push(data[k + j]);\n          }\n        }\n      }\n    }\n\n    return nextData;\n  }\n\n  private _createTree(data: number[]): KDBush {\n    const numItems = (data.length / STRIDE) | 0;\n    const tree = new KDBush(numItems, 64, Float32Array);\n    for (let i = 0; i < data.length; i += STRIDE) {\n      tree.add(data[i], data[i + 1]);\n    }\n    tree.finish();\n    return tree;\n  }\n\n  private _limitZoom(zoom: number): number {\n    return Math.max(\n      this.minZoom,\n      Math.min(Math.floor(+zoom), this.maxZoom + 1),\n    );\n  }\n\n  private _emptyOutput(): ClusterOutput {\n    return {\n      positions: new Float64Array(0),\n      pointCounts: new Uint32Array(0),\n      ids: new Float64Array(0),\n      isCluster: new Uint8Array(0),\n      length: 0,\n    };\n  }\n\n  private _mergeOutputs(a: ClusterOutput, b: ClusterOutput): ClusterOutput {\n    const length = a.length + b.length;\n    const positions = new Float64Array(length * 2);\n    const pointCounts = new Uint32Array(length);\n    const ids = new Float64Array(length);\n    const isCluster = new Uint8Array(length);\n\n    positions.set(a.positions);\n    positions.set(b.positions, a.length * 2);\n    pointCounts.set(a.pointCounts);\n    pointCounts.set(b.pointCounts, a.length);\n    ids.set(a.ids);\n    ids.set(b.ids, a.length);\n    isCluster.set(a.isCluster);\n    isCluster.set(b.isCluster, a.length);\n\n    return { positions, pointCounts, ids, isCluster, length };\n  }\n}\n"],"mappings":"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"}